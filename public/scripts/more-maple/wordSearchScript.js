let activeRowNum = -1;
let activeColNum = -1;
let direction = "";
let grid = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

document.addEventListener('DOMContentLoaded', () => {
    let allSquares = document.querySelectorAll(".single-square");

    // For all squares, on click, check the following conditions:
    // 1) If no squares are active, activate the selected square
    // 2) If a square is already active, check if it's the same square
    //// a) If square is same square, deactivate square
    //// b) If square is different, check if position is valid (same row, col or diagonal)
    ////// i) If position is invalid, deactivate previously active square
    ////// ii) If position is valid, check if word generated by row/col/diag of characters matches required clue
    //////// - If does not match the clue, deactivate active square (and all actively highlighted squares)
    //////// - If matches the clue, activate all squares and strikethrough clue, reset activeRow/activeCol
    allSquares.forEach(square => {
        square.addEventListener("click", event => {
            checkSquarePosition(square);
        })
    })

    closeBoardListener();
})

function closeBoardListener() {
    let closeBtn = document.getElementById("close-board-btn");

    closeBtn.addEventListener("click", () => {
        document.getElementById("congrats-msg").classList.add("d-none");
        document.getElementById("congrats-msg").classList.remove("d-flex");
        document.getElementById("word-search-board-blocker").classList.add("complete");
    })
}

function resetActiveSquare() {
    activeRowNum = -1;
    activeColNum = -1;
    document.querySelector(".selected").classList.remove("selected");
}

// 1) If no squares are active, activate the selected square
// 2) If a square is already active, check if it's the same square
function checkSquarePosition(square) {
    if(activeRowNum === -1 && activeColNum === -1) {
        activeRowNum = parseInt(square.dataset.rowNum);
        activeColNum = parseInt(square.dataset.colNum);

        square.classList.add("selected");
    } else {
        checkIfSameSquare(square);
    }
}

//// a) If square is same square, deactivate square
//// b) If square is different, check if position is valid (same row, col or diagonal)
function checkIfSameSquare(square) {
    if(square.classList.contains("selected")) {
        resetActiveSquare();
    } else {
        isValidSquarePosition(square, parseInt(square.dataset.rowNum), parseInt(square.dataset.colNum));
    }
}

function isValidSquarePosition(square, selectedSquareRowNum, selectedSquareColNum) {
    let rowDiff = selectedSquareRowNum - activeRowNum;
    let colDiff = selectedSquareColNum - activeColNum;

    if(rowDiff === 0 || colDiff === 0 || Math.abs(rowDiff) === Math.abs(colDiff)) {
        checkWordGenerated(square, selectedSquareRowNum, selectedSquareColNum, rowDiff, colDiff);
    } else {
        ////// i) If position is invalid, deactivate previously active square
        resetActiveSquare();
    }
}

////// ii) If position is valid, check if word generated by row/col/diag of characters matches required clue
//////// - If does not match the clue, deactivate active square (and all actively highlighted squares)
//////// - If matches the clue, activate all squares and strikethrough clue, reset activeRow/activeCol
function checkWordGenerated(square, selectedSquareRowNum, selectedSquareColNum, rowDiff, colDiff) {
    let startingChar = getCharacter(activeRowNum, activeColNum);
    let wordCreated = startingChar;
    let currRowNum = activeRowNum;
    let currColNum = activeColNum;
    let affectedSquares = [{ row: currRowNum, col: currColNum}];

    while(currRowNum !== selectedSquareRowNum || currColNum !== selectedSquareColNum) {
        // Letter is on same row
        if(rowDiff === 0) {
            currColNum = updateColNum(colDiff, currColNum);
            direction = "horz";
        }

        // Letter is on same col
        if(colDiff === 0) {
            currRowNum = updateRowNum(rowDiff, currRowNum);
            direction = "vert";
        }

        // Letter is on valid diagonal
        if(Math.abs(colDiff) === Math.abs(rowDiff)) {
            currColNum = updateColNum(colDiff, currColNum);
            currRowNum = updateRowNum(rowDiff, currRowNum);

            if(colDiff === rowDiff) {
                direction = "diag-45";
            } else {
                direction = "diag-135";
            }
        }

        wordCreated += getCharacter(currRowNum, currColNum);
        affectedSquares.push({ row: currRowNum, col: currColNum });
    }

    if(checkMatchingWord(square, wordCreated)) {
        highlightSquares(affectedSquares);
        resetActiveSquare();
        checkRemainingWords();
    } else {
        resetActiveSquare();
    }
}

function getCharacter(rowNum, colNum) {
    return document.getElementById(`square-${rowNum}-${colNum}`).textContent.trim();
}

function updateColNum(colDiff, colNum) {
    if(colDiff < 0) {
        colNum--;
    } else {
        colNum++;
    }

    return colNum;
}

function updateRowNum(rowDiff, rowNum) {
    if(rowDiff < 0) {
        rowNum--;
    } else {
        rowNum++;
    }

    return rowNum;
}

function checkMatchingWord(square, wordCreated) {
    let wordList = Array.from(document.querySelectorAll(".word-to-find")).filter(elem => elem.classList.contains("word-found") === false);
    let isWordFound = false;

    wordList.every(elem => {
        let wordWithoutSpace = elem.textContent.toUpperCase().replace(/ /g, '');

        if(wordCreated === wordWithoutSpace || wordCreated.split("").reverse().join("") === wordWithoutSpace) {
            isWordFound = true;
            elem.classList.add("word-found");
            return false;
        }
        return true;
    })

    return isWordFound;
}

function highlightSquares(squaresToHighlight) {
    squaresToHighlight.forEach(coords => {
        let affectedSquare = document.getElementById(`square-${coords.row}-${coords.col}`);

        affectedSquare.classList.add("highlight");
        affectedSquare.insertAdjacentHTML('afterbegin', `<hr class="position-absolute ${direction}">`);

        grid[coords.row][coords.col] = 1;
    })
}

function checkRemainingWords() {
    let remainingWords = Array.from(document.querySelectorAll(".word-to-find")).filter(elem => elem.classList.contains("word-found") === false);

    if(remainingWords.length === 0) {
         document.getElementById("word-search-board-blocker").classList.remove("d-none")
         document.getElementById("word-search-board-blocker").classList.add("d-flex")
    }
}