let activeRowNum = -1;
let activeColNum = -1;
let direction = "";
let grid = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

document.addEventListener('DOMContentLoaded', () => {
    let allSquares = document.querySelectorAll(".single-square");

    // For all squares, on click, check the following conditions:
    // 1) If no squares are active, activate the selected square
    // 2) If a square is already active, check if it's the same square
    //// a) If square is same square, deactivate square
    //// b) If square is different, check if position is valid (same row, col or diagonal)
    ////// i) If position is invalid, deactivate previously active square
    ////// ii) If position is valid, check if word generated by row/col/diag of characters matches required clue
    //////// - If does not match the clue, deactivate active square (and all actively highlighted squares)
    //////// - If matches the clue, activate all squares and strikethrough clue, reset activeRow/activeCol
    allSquares.forEach(square => {
        square.addEventListener("click", event => {
            checkSquarePosition(square);
        })
    })

    addSubmitBoardListener();
})

function addSubmitBoardListener() {
    let submitBoardBtn = document.querySelector(".submit-board-btn")

    submitBoardBtn.addEventListener("click", event => {
        event.preventDefault();

        let discordName = document.getElementById("discord-name").value;

        fetch("/maple/fun/word-search", {
            headers: {
                'Content-Type': 'application/json'
            },
            method: 'POST',
            body: JSON.stringify({ name: discordName, grid: grid })
        })
        .then(response => response.json())
        .then(data => {
            document.getElementById("submit-board-div").classList.add("d-none");
            document.getElementById("submit-board-div").classList.remove("d-flex");
            document.getElementById("submit-status-div").classList.remove("d-none");

            if(data.isErr) {
                throw Error(data.err);
            } else {
                if(data.isValid) {
                    document.getElementById("submit-status-div").textContent = "Details successfully submitted! Thanks for participating~";
                } else {
                    document.getElementById("submit-status-div").textContent = "Welp. The correct board doesn't match up so your submission is invalid. Guess you'll need to restart!";
                }
            }
        })
        .catch(error => {
            document.getElementById("submit-status-div").textContent = `Something went wrong! ${error}`;
        })
    })
}

function resetActiveSquare() {
    activeRowNum = -1;
    activeColNum = -1;
    document.querySelector(".selected").classList.remove("selected");
}

// 1) If no squares are active, activate the selected square
// 2) If a square is already active, check if it's the same square
function checkSquarePosition(square) {
    if(activeRowNum === -1 && activeColNum === -1) {
        activeRowNum = parseInt(square.dataset.rowNum);
        activeColNum = parseInt(square.dataset.colNum);

        square.classList.add("selected");
    } else {
        checkIfSameSquare(square);
    }
}

//// a) If square is same square, deactivate square
//// b) If square is different, check if position is valid (same row, col or diagonal)
function checkIfSameSquare(square) {
    if(square.classList.contains("selected")) {
        resetActiveSquare();
    } else {
        isValidSquarePosition(square, parseInt(square.dataset.rowNum), parseInt(square.dataset.colNum));
    }
}

function isValidSquarePosition(square, selectedSquareRowNum, selectedSquareColNum) {
    let rowDiff = selectedSquareRowNum - activeRowNum;
    let colDiff = selectedSquareColNum - activeColNum;

    if(rowDiff === 0 || colDiff === 0 || Math.abs(rowDiff) === Math.abs(colDiff)) {
        checkWordGenerated(square, selectedSquareRowNum, selectedSquareColNum, rowDiff, colDiff);
    } else {
        ////// i) If position is invalid, deactivate previously active square
        resetActiveSquare();
    }
}

////// ii) If position is valid, check if word generated by row/col/diag of characters matches required clue
//////// - If does not match the clue, deactivate active square (and all actively highlighted squares)
//////// - If matches the clue, activate all squares and strikethrough clue, reset activeRow/activeCol
function checkWordGenerated(square, selectedSquareRowNum, selectedSquareColNum, rowDiff, colDiff) {
    let startingChar = getCharacter(activeRowNum, activeColNum);
    let wordCreated = startingChar;
    let currRowNum = activeRowNum;
    let currColNum = activeColNum;
    let affectedSquares = [{ row: currRowNum, col: currColNum}];

    while(currRowNum !== selectedSquareRowNum || currColNum !== selectedSquareColNum) {
        // Letter is on same row
        if(rowDiff === 0) {
            currColNum = updateColNum(colDiff, currColNum);
            direction = "horz";
        }

        // Letter is on same col
        if(colDiff === 0) {
            currRowNum = updateRowNum(rowDiff, currRowNum);
            direction = "vert";
        }

        // Letter is on valid diagonal
        if(Math.abs(colDiff) === Math.abs(rowDiff)) {
            currColNum = updateColNum(colDiff, currColNum);
            currRowNum = updateRowNum(rowDiff, currRowNum);

            if(colDiff === rowDiff) {
                direction = "diag-45";
            } else {
                direction = "diag-135";
            }
        }

        wordCreated += getCharacter(currRowNum, currColNum);
        affectedSquares.push({ row: currRowNum, col: currColNum });
    }

    if(checkMatchingWord(square, wordCreated)) {
        highlightSquares(affectedSquares);
        resetActiveSquare();
        checkRemainingWords();
    } else {
        resetActiveSquare();
    }
}

function getCharacter(rowNum, colNum) {
    return document.getElementById(`square-${rowNum}-${colNum}`).textContent.trim();
}

function updateColNum(colDiff, colNum) {
    if(colDiff < 0) {
        colNum--;
    } else {
        colNum++;
    }

    return colNum;
}

function updateRowNum(rowDiff, rowNum) {
    if(rowDiff < 0) {
        rowNum--;
    } else {
        rowNum++;
    }

    return rowNum;
}

function checkMatchingWord(square, wordCreated) {
    let wordList = Array.from(document.querySelectorAll(".word-to-find")).filter(elem => elem.classList.contains("word-found") === false);
    let isWordFound = false;

    wordList.every(elem => {
        let wordWithoutSpace = elem.textContent.toUpperCase().replace(/ /g, '');

        if(wordCreated === wordWithoutSpace || wordCreated.split("").reverse().join("") === wordWithoutSpace) {
            isWordFound = true;
            elem.classList.add("word-found");
            return false;
        }
        return true;
    })

    return isWordFound;
}

function highlightSquares(squaresToHighlight) {
    squaresToHighlight.forEach(coords => {
        let affectedSquare = document.getElementById(`square-${coords.row}-${coords.col}`);

        affectedSquare.classList.add("highlight");
        affectedSquare.insertAdjacentHTML('afterbegin', `<hr class="position-absolute ${direction}">`);

        grid[coords.row][coords.col] = 1;
    })
}

function checkRemainingWords() {
    let remainingWords = Array.from(document.querySelectorAll(".word-to-find")).filter(elem => elem.classList.contains("word-found") === false);

    if(remainingWords.length === 0) {
         document.querySelector(".word-search-board-blocker").classList.remove("d-none")
         document.querySelector(".word-search-board-blocker").classList.add("d-flex")
    }
}